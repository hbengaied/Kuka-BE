% ICI je vais faire un rappel théorique du projet
% Je vais aussi parler du matériel utilisé, des contrainte et enfin des étapes qu'on a dû réalisé
\section{Introduction}

Notre projet consiste à programmer un robot KUKA de telle sorte qu'il puisse écrire sur un clavier seul.


\subsection{KUKA}

\lettrine[nindent=0em,lines=3]{D}ans le cadre de mon projet d'étude, on a développé un système permettant à un bras mécanique KUKA de taper des choses sur un clavier.
L'automatisation des tâches est devenue essentielle dans de nombreux domaines, et l'utilisation de bras mécaniques offre de vastes possibilités pour améliorer l'efficacité et la précision des processus.
\\
\\
Kuka est avant tout une entreprise de robotique.
C'est une société mondiale d'automatisation.
Le siège de la société se trouve en Allemagne.
%------------------------------------------------

\section{Description des différentes parties du projet}

Lors de ce projet, nous sommes passer par plusieurs étapes.
Voici une description brève des étapes ;

\begin{itemize}
    \item Maintenir une connexion avec le robot.
    \item Configurer ses entrés pour qu'il puisse recevoir des coordonnées.
    \item Programmer en KRL afin qu'il puisse utilisé ses entrés et procéder à des mouvements.
    \item Bouger le robot avec les coordonnées envoyées.
    \item Prendre les coordonnées des touches du clavier.
    \item Bouger le robot pour qu'il puisse taper sur le clavier juste en lui donnant la phrase à taper.
    \item Initialiser les étapes à suivre pour que le robot sache ou appuyer pour réaliser un post.
\end{itemize}


%------------------------------------------------
\section{Matériel et Méthode}

Les outils utilisés sont les suivants ;

\begin{itemize}
    \item Un robot KUKA
    \item Un ordinateur
    \item Un clavier mécanique
    \item Un support pour le clavier
\end{itemize}

En ce qui concerne le language utilisé lors de ce projet.
On a dû utiliser deux languages de programmation, \textbf{Python} et le \textbf{KRL}.
\\
\\
Python a été utilisé pour instancié le serveur.
Ce serveur permet de maintenir la connexion, recevoir/envoyer des coordonnées, vérifier des coordonnées et séquencer la phrase que le robot doit taper.
Les informations que le serveur envoie au robot est sous format \textbf{XML}.
\\
\\
Le KRL permet de se connecter au serveur et d'utiliser les informations que le serveur lui envoie.
Pour que le connexion se fasse, le programme a besoin d'information tels que l'adresse ip et le port du serveur.
Ces informatios se retrouve dans un fichier XML.
Ce fichier possède aussi d'autres informations tels que les données en entrés et en sortie du robot.
\\
\\
Et en ce qui concerne le support de clavier, ce support est obligatoire en vue de respecter la zone de travail du robot.
En effet, le robot possède une zone de travail.
Lorsque le robot est hors de cette zone, le robot est inutillisable.
Cette zone permet d'avoir une sécurité.
Elle permet en autre d'éviter que le robot soit en conatct avec le plan de travail par exemple.
\\
\\
Remarque, la phrase que le robot devra taper ne doit pas être longue.
Si la phrase est trop longue à écrire, le temps pour que le robot tape la phrase est prolongé.

\subsection{Connexion}

En ce qui concerne la connexion.
Le robot est connecté en \textbf{VLAN}.
Donc, il n'est pas directement lié au réseau.
Pour pouvoir communiquer avec celui-ci, on est obligé de se connecte au VLAN.
\\
\\
Lorsque la communication entre le serveur et le robot est assurés, on peut passer à l'étape suivante qui consiste à créer un fichier XML.
Ce fichier XML contiendra toute les informations afin d'assurer la connexion.
Comme par exemple, l'adresse ip du serveur, le port que le serveur utilise et le protocol utilisé pour communiquer.
\\
\\
Et enfin, lorsque le fichier XML est bien configuré, on peut passer au programme KRL.
On a crée un objet \textbf{RSI} de type \textbf{ST\_ETHERNET}.
Cette objet spécifique au language \textbf{KRL} permettra d'initialisé la connexion.
Lorsque la connexion a été établie, le robot commence par envoyé le premier fichier XML au serveur.
Ce premier fichier contiendra des informations comme les coordonnées, mais aussi un \textbf{IPOC}.
Cette valeur est composée de chiffre.
Elle devra être renvoyé au robot selon un temps impartie.
Si cette valeur n'est pas renvoyé dans les plus bréves délais, alors la connexion s'interromt.

\subsection{Configuration du fichier XML}

Comme expliqué précédement, le fichier XML permet de configuré la connexion du robot au serveur.
Toutefois, ce fichier contient d'autre informations.
Voyons voir de plus près l'architecture de ce fichier.
\\
\\
La balise racine de ce fichier se nomme "\textbf{ROOT}".
Dans la balise racine se trouve 3 autres balises.
Il y a une balise qui se nomme "\textbf{CONFIG}", une autre "\textbf{SEND}" et la dernière s'appelle "\textbf{RECEIVE}".
\\
\\
La balise \textbf{CONFIG} va permettre de configurer les paramètres de communication.
On va y retrouver 6 autres balises ;
\begin{itemize}
    \item "\textbf{IP\_NUMBER}" contenant l'addresse IP du serveur.
    \item "\textbf{PORT}" permettant d'avoir le port utilisé par le serveur.
    \item "\textbf{PROTOCOL}" qui défini le protocole utilisé pour la communication. On a deux types de protocoles utilisable, on a le droit d'utiliser le protocole \textbf{TCP} ou \textbf{UDP}.
    \item "\textbf{SENDTYPE}" est l'identifieur du système externe. Cette valeur va être identifier pour chaques paquets reçu au robot.
    \item "\textbf{PROTOCOLLENGTH}" est une balise permettant d'activier la transmission de la longueur de byte du protocole. Elle n'a que deux valeurs possibles ("\textbf{ON}" ou "\textbf{OFF}").
    \item Et enfin, la balise "\textbf{ONLYSEND}" permet de définir la direction des échanges de donnée. Elle peut être mis à "\textbf{TRUE}", ceci permet au robot d'envoyer des données mais pas d'en recevoir. Tandis que, lorsqu'il est mis à "\textbf{FALSE}", alors le système peut envoyer et recevoir des données. 
\end{itemize}
Concernant la balise \textbf{PROTOCOLLENGTH}, il a été initialisé à \textbf{OFF} et la balise \textbf{ONLYSEND} a été initialisé à \textbf{FALSE}.
\\
\\
Ensuite, la balise \textbf{SEND} permet de définir ce que le robot peut envoyer.
Cette balise contient une sous-balise "\textbf{ELEMENTS}".
Cette balise conteint aussi d'autres balises "\textbf{ELEMENT}".
La balise \textbf{ELEMENT} a des attributs tels que ;
\begin{itemize}
    \item \textbf{TAG} est le nom du tag qui sera généré par le robot.
    \item \textbf{TYPE} est le type de donnée.
    \item \textbf{INDX} est le numéro de sorite de l'objet.
    \item Et enfin, \textbf{UNIT} est l'unité utilisé pour la donnée.
\end{itemize}
Pour ce projet, j'ai juste besoin des coordonnées du robot.
Le système possède déjà un objet préconfiguré qui se nomme "\textbf{DEF\_RIst}".
C'est dans l'attribut \textbf{TAG} où on précise le nom de cette objet.
Le type de cette objet est un \textbf{DOUBLE}, le numéro de sortie est \textbf{INTERNAL} et l'unité est \textbf{0}.
\\
\\
Remarque, il existe plein d'autres mots-clés comme \textbf{DEF\_RSol} (envoie les commandes de positions cartésienne), ou le \textbf{DEF\_MACur} (envoie les courants moteur du robot de l'axe A1 à A6).
\\
\\
Et enfin, la balise \textbf{RECEIVE} est la balise qui définie la sortie du robot.
Cette balise à la même architecture que la balise \textbf{SEND}.
Toutefois, la balise \textbf{ELEMENT} contient un attribut en plus, c'est le \textbf{HOLDON}.
Ce nouveau attribut va définir le comportement de l'objet reçu au robot lorsque celle-ci à une erreur.
Elle a deux valeurs possibles ;
\begin{itemize}
    \item \textbf{0} permet de réinitialisé la veleurs reçu.
    \item \textbf{1} permet de maintenir l'ancienne valeur valide alors que la nouvelle valeur a une erreur.
\end{itemize}
Dans ce projet, tous les eléments ont un \textbf{HOLDON} à \textbf{1} afin d'assurer une localisation toujour valide.

\subsection{Programmation en KRL}

Passons maintenant dans le language KRL, on va définir les différents principes et outils utilisés dans le programme.
\\
\\
Au début du programme, on commence d'abord par déclaré les variables utiles.
Une variable de type \textbf{RSIERR} est déclaré.
Cette variable permet, en autre, de récupérer la réponse d'une commande.
Des variables de type \textbf{INT} seront utilisées afin de stocker des entiers.
Il y aura un entier (nommé \textbf{hEthernet}) contenant l'identifiant de l'objet permettant l'accés à l'objet \textbf{RSI}.
Cette valeur est automatiquement assigné par le système lorsque l'objet RSI est créer.
D'autres entiers seront utilisés pour identifié l'objet RSI.
Et enfin, une variable de type \textbf{FRAME} sera déclaré.
C'est une variable permettant de faire la liaison avec le capteur de coordonnée du système.
Elle permet notemment de changer les coordonnées selon des nouvelles coordonnées reçu par le robot.
\\
\\
Lorsque les déclarations de variables sont terminées.
On peut alors passer à la configuration de l'objet \textbf{RSIERR} avec des méthodes mises à dispositions.
\\
\\
La communication entre le controlleur du robot et un système externe est implémenté en utilisant l'objet \textbf{RSI ST\_ETHERNET}.
Cette objet doit être crée et configuré dans le programme KRL afin de établir la communication.
Pour activer la communication entre ces systèmes, l'utilisateur doit créer et configurer le fichier XML.
Ce fichier de configuration est spécifié et charger lorsque l'objet RSI ST\_ETHERNET est crée.
Cette objet prend trois paramètres.
\\
\\
Le premier paramètre est l'identifiant de l'objet permettant l'accés à l'objet \textbf{RSI}.
Dans notre cas, cette variable est appellé \textbf{hEthernet}.
\\
\\
Le deuxième paramètre est un entier correspondant au nombre de containeur dans lequel l'objet RSI est crée.
Nous ne voulons pas créer de containeur, on va donc précisé qu'aucun containeur doit être crée.
\\
\\
Et enfin, le troisème paramétre est le chemin d'accés vers le fichier de configuration XML. 
\\
\\
L'objet RSI ST\_ETHERNET peut être configurer à l'aide de la commande \textbf{ST\_SETPARAM}.
La seule configuration faite concerne le nombre maximum de paquet de donnée pouvant arrivé en retard au controlleur du robot.
Ce paramètre se nomme \textbf{eERXmaxLatePackages} et on a définie ce nombre maximum à 500.
Ce qui signifie que 500 est le nombre maximum de paquet de donnée qui peut être en retard.
\\
\\
Lorsque la partie concernant la connexion est terminé, on peut commencer à mapper les entrés de données du robot.
Pour réaliser cela, on utilise l'objet \textbf{RSI ST\_MAP2SEN\_PREA}.
Cette objet permet donc de rendre disponible la lecture de donnée que le système externe envoie.
Il prend cinq paramètres ;
\begin{itemize}
    \item Le premier paramètre est l'identifiant de l'objet. C'est donc un entier. Dans le programme KRL, il sera nommé \textbf{hMap2Prea}.
    \item Le deuxième paramètre est le numéro du containeur de l'objet RSI, dans notre cas, c'est le containeur 0.
    \item Le troisème paramètre est l'identifiant de l'objet permettant l'accés à l'objet \textbf{RSI} (hEthernet).
    \item Ensuite, le quatrième paramètre est l'index de la source de signal. Ceci est directement lié à la configuration du fichier XML, dans la balise \textbf{RECEIVE}.
    \item Et enfin, le cinquième paramètre est l'indice de la variable de système \textbf{\$SEN\_PREA[]}.
\end{itemize}
Remarque importante, les variables seront accessible avec la variables du système \textbf{\$SEN\_PREA[X]}.
Où le terme "X" est l'indice qu'on utilise pour accéder à la variable reçu.
\\
\\
Pour la sécurité du matériel, on active un cycle de correction.
Ce cycle permet de corrigé les mouvements selon le système de référence qu'on utilise.
On utilise le système \textbf{\#WORLD}.
Pour activé cette correction, on utilise la commande \textbf{ST\_ON1(\#WORLD,1)}.
\\
\\
On peut enfin passer dans la création d'une boucle permettant de récupérer les nouvelles coordonnées envoyé par le système extenre.
Dans cette boucle, on utilise la variable de type \textbf{FRAME}.
Cette variable va contenir les nouvelles coordonnées à l'aide de la variable \textbf{\$SEN\_PREA[X]}.
Lorsque les coordonnées sont initialisées, alors on peut procéder à un mouvement de type \textbf{PTP} (Point To Point).
Ce type de mouvement point par point ne permet pas d'avoir un mouvement linéaire.
Il permet juste de passer à un point dans l'espace qu'on définie avec une coordonnée.

\subsection{Mouvement}

Dans cette partie, nous allons discuter des différents types de mouvements effectués par le bras Kuka afin de répondre aux différents besoins de notre projet. 
Les mouvements que nous allons aborder vont permettre d'écrire sur le clavier et de publier le tweet.

\subsubsection{Mouvement clavier}

Le mouvement du clavier a été décomposé en 3 parties.
La première étape consiste à se positionner au-dessus de la touche à écrire.
Le bras Kuka se déplace en X et Y uniquement pour cette phase. 
Une fois positionné au-dessus de la touche, le bras effectue un déplacement en Z pour appuyer sur la touche. 
Après avoir pressé la touche, le bras effectue à nouveau un déplacement en Z pour se retirer de la touche. 
Ce cycle est répété jusqu'à ce que le bras ait fini d'écrire la phrase souhaitée.
Les coordonnées de chaque touche sont stockées dans un dictionnaire appelé "Dico" dans le fichier MovementManager.py.
Ces coordonnées sont transmises au robot en fonction de la touche à écrire.
Elles permettent également d'effectuer plusieurs vérifications en comparant la position à atteindre et la position actuelle du bras :

\begin{enumerate}
    \item Vérifier que le robot se trouve bien au-dessus de la touche concernée.
    \item Vérifier que le robot a bien appuyé sur la touche du clavier.
    \item Vérifier que le robot s'est bien relevé après l'appui.
\end{enumerate}

Ces comparaisons permettent de garantir la précision et l’exactitude des mouvements à
effectuer par le bras Kuka lors de l’écriture sur le clavier.

\subsubsection{Soumission du tweet}

Une fois la phrase entièrement écrite, le robot doit maintenant soumettre le tweet.
Pour cela, nous utilisons la touche de tabulation huit fois afin de sélectionner le bouton "Tweet".
Une fois ce bouton sélectionné, nous ordonnons au robot de se diriger vers la touche "Enter" du clavier et d'appuyer dessus pour soumettre notre tweet.
Les coordonnées de la touche "Enter" et "Tabulation" sont également stockées dans un dictionnaire appelé "MousePos", qui se trouve dans le fichier MovementManager.py.
Les mêmes vérifications que celles effectuées pour l'écriture sur le clavier sont appliquées pour soumettre le tweet.
Une fois notre tweet soumis, le robot peut écrire un autre message s'il le souhaite en répétant le même schéma.

\subsection{Twitter}

Lors du lancement du programme, le robot va directement appuyer sur la touche "N".
Cette touche est un raccourci proposé par Twitter pour ouvrir rapidement et facilement la fenêtre d'écriture des tweets.
Les coordonnées permettant d'utiliser cette option sont stockées dans le dictionnaire "MousePos" sous le nom de "new", situé dans le fichier MovementManager.py.
Une fois la fenêtre ouverte, le robot va commencer à rédiger son tweet, puis le soumettre.

