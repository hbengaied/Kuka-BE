% ICI je vais faire un rappel théorique du projet
% Je vais aussi parler du matériel utilisé, des contrainte et enfin des étapes qu'on a dû réalisé
\section{Introduction}

Notre objectif est de programmer un robot KUKA de manière à lui permettre d'écrire sur un clavier de manière autonome.

\subsection{KUKA}

\lettrine[nindent=0em,lines=3]{D}ans le cadre de mon projet d'étude, nous avons créé un système qui permet à un bras mécanique KUKA d'effectuer la saisie de texte sur un clavier. 
L'automatisation des tâches est devenue indispensable dans de nombreux domaines, et l'utilisation de bras mécaniques offre de nombreuses opportunités pour améliorer l'efficacité et la précision des processus.
\\
\\
KUKA est avant tout une entreprise de robotique.
Elle est une société mondiale spécialisée dans l'automatisation.
Le siège de l'entreprise est situé en Allemagne.
%------------------------------------------------

\section{Description des différentes parties du projet}

Lors de ce projet, nous sommes passer par plusieurs étapes.
Voici une description brève des étapes ;

\begin{itemize}
    \item Assurer une connexion continue avec le robot.
    \item Configurer les entrées du robot pour recevoir des coordonnées.
    \item Programmer en KRL afin que le robot puisse utiliser ces coordonnées pour effectuer des mouvements.
    \item Déplacer le robot en utilisant les coordonnées envoyées.
    \item Prendre les coordonnées des touches du clavier.
    \item Contrôler les mouvements du robot de manière à ce qu'il puisse taper sur le clavier en lui fournissant simplement la phrase à écrire.
    \item Établir les étapes initiales nécessaires pour que le robot sache où appuyer afin d'effectuer une publication.
\end{itemize}


%------------------------------------------------
\section{Matériel et Méthode}

Les outils utilisés sont les suivants ;

\begin{itemize}
    \item Un robot KUKA
    \item Un ordinateur
    \item Un clavier mécanique
    \item Un support pour le clavier
\end{itemize}

En ce qui concerne le language utilisé lors de ce projet.
On a dû utiliser deux languages de programmation, \textbf{Python} et le \textbf{KRL}.
\\
\\
Python a été utilisé pour instancié le serveur.
Ce serveur permet de maintenir la connexion, recevoir/envoyer des coordonnées, vérifier des coordonnées et séquencer la phrase que le robot doit taper.
Les informations que le serveur envoie au robot est sous format \textbf{XML}.
\\
\\
Python a été utilisé pour créer une instance du serveur.
Ce serveur assure la maintenance de la connexion, la réception et l'envoi des coordonnées, la vérification des coordonnées et la séquentialisation de la phrase que le robot doit taper.
Les informations transmises du serveur au robot sont formatées en \textbf{XML}.
\\
\\
Le support de clavier est indispensable pour respecter la zone de travail du robot.
En effet, le robot dispose d'une zone de travail définie.
Lorsqu'il se trouve en dehors de cette zone, le robot devient inutilisable.
Cette zone de travail est essentielle pour garantir la sécurité.
Elle permet notamment d'éviter tout contact indésirable entre le robot et le plan de travail, par exemple.
\\
\\
Notez que la phrase que le robot doit taper ne doit pas être trop longue.
Si la phrase est excessive en longueur, cela prolongera le temps nécessaire pour que le robot la tape.

\subsection{Connexion}

Pour la connexion, le robot est connecté via un \textbf{VLAN}, ce qui signifie qu'il n'est pas directement connecté au réseau principal.
Afin de communiquer avec le robot, il est nécessaire de se connecter au VLAN spécifique associé.
\\
\\
Une fois que la communication entre le serveur et le robot est établie, on peut passer à l'étape suivante, qui consiste à créer un fichier XML.
Ce fichier XML contiendra toutes les informations nécessaires pour établir la connexion, telles que l'adresse IP du serveur, le port utilisé par le serveur et le protocole de communication utilisé.
\\
\\
Enfin, une fois que le fichier XML est correctement configuré, nous pouvons passer au programme KRL.
Nous avons créé un objet RSI (Robot Sensor Interface) de type \textbf{ST\_ETHERNET}.
Cet objet spécifique au langage KRL permet d'initialiser la connexion.
Une fois que la connexion est établie, le robot commence par envoyer le premier fichier XML au serveur.
Ce premier fichier contient des informations telles que les coordonnées ainsi qu'un IPOC (Internal Point of Control).
Cette valeur IPOC est une séquence numérique qui doit être renvoyée au robot dans un délai imparti.
Si cette valeur n'est pas renvoyée dans les plus brefs délais, la connexion est interrompue.

\subsection{Configuration du fichier XML}

Comme expliqué précédement, le fichier XML permet de configuré la connexion du robot au serveur.
Toutefois, ce fichier contient d'autre informations.
Voyons voir de plus près l'architecture de ce fichier.
\\
\\
La balise racine de ce fichier se nomme "\textbf{ROOT}".
Dans la balise racine se trouve 3 autres balises.
Il y a une balise qui se nomme "\textbf{CONFIG}", une autre "\textbf{SEND}" et la dernière s'appelle "\textbf{RECEIVE}".
\\
\\
La balise \textbf{CONFIG} permet de configurer les paramètres de communication.
On va y retrouver 6 autres balises ;
\begin{itemize}
    \item "\textbf{IP\_NUMBER}" contenant l'addresse IP du serveur.
    \item "\textbf{PORT}" permettant d'avoir le port utilisé par le serveur.
    \item "\textbf{PROTOCOL}" qui défini le protocole utilisé pour la communication. On a deux types de protocoles utilisable, on a le droit d'utiliser le protocole \textbf{TCP} ou \textbf{UDP}.
    \item "\textbf{SENDTYPE}" est l'identifieur du système externe. Cette valeur va être identifier pour chaques paquets reçu au robot.
    \item "\textbf{PROTOCOLLENGTH}" est une balise permettant d'activier la transmission de la longueur de byte du protocole. Elle n'a que deux valeurs possibles ("\textbf{ON}" ou "\textbf{OFF}").
    \item Et enfin, la balise "\textbf{ONLYSEND}" permet de définir la direction des échanges de donnée. Elle peut être mis à "\textbf{TRUE}", ceci permet au robot d'envoyer des données mais pas d'en recevoir. Tandis que, lorsqu'il est mis à "\textbf{FALSE}", alors le système peut envoyer et recevoir des données. 
\end{itemize}
Concernant la balise \textbf{PROTOCOLLENGTH}, il a été initialisé à \textbf{OFF} et la balise \textbf{ONLYSEND} a été initialisé à \textbf{FALSE}.
\\
\\
Ensuite, la balise \textbf{SEND} permet de définir ce que le robot peut envoyer.
Cette balise contient une sous-balise "\textbf{ELEMENTS}".
Cette balise contient aussi d'autres balises "\textbf{ELEMENT}".
La balise \textbf{ELEMENT} a des attributs tels que ;
\begin{itemize}
    \item \textbf{TAG} est le nom du tag qui sera généré par le robot.
    \item \textbf{TYPE} est le type de donnée.
    \item \textbf{INDX} est le numéro de sorite de l'objet.
    \item Et enfin, \textbf{UNIT} est l'unité utilisé pour la donnée.
\end{itemize}
Pour ce projet, on avait seulement besoin des coordonnées du robot. Le système dispose déjà d'un objet préconfiguré appelé "\textbf{DEF\_RIst}".
C'est dans l'attribut "TAG" qu'on spécifie le nom de cet objet.
Le type de cet objet est "DOUBLE", le numéro de sortie est "INTERNAL" et l'unité est "0".
Cela nous permettra de récupérer les coordonnées du robot de manière précise et cohérente dans votre programme.
\\
\\
Remarque, il existe plein d'autres mots-clés comme \textbf{DEF\_RSol} (envoie les commandes de positions cartésienne), ou le \textbf{DEF\_MACur} (envoie les courants moteur du robot de l'axe A1 à A6).
\\
\\
Et enfin, la balise \textbf{RECEIVE} est la balise qui définie la sortie du robot.
Cette balise a la même architecture que la balise \textbf{SEND}.
Toutefois, la balise \textbf{ELEMENT} contient un attribut en plus, c'est le \textbf{HOLDON}.
Ce nouveau attribut va définir le comportement de l'objet reçu au robot lorsque celle-ci à une erreur.
Elle a deux valeurs possibles ;
\begin{itemize}
    \item \textbf{0} permet de réinitialiser la valeurs reçu.
    \item \textbf{1} permet de maintenir l'ancienne valeur valide alors que la nouvelle valeur a une erreur.
\end{itemize}
Dans ce projet, tous les eléments ont un \textbf{HOLDON} à \textbf{1} afin d'assurer une localisation toujour valide.

\subsection{Programmation en KRL}

Passons maintenant dans le language KRL, on va définir les différents principes et outils utilisés dans le programme.
\\
\\
Au début du programme, on commence d'abord par déclarer les variables utiles.
Une variable de type \textbf{RSIERR} est déclaré.
Cette variable permet, en autre, de \textbf{récupérer} la réponse d'une commande.
Des variables de type \textbf{INT} seront utilisées afin de stocker des entiers.
Il y aura un entier (nommé \textbf{hEthernet}) contenant l'identifiant de l'objet permettant l'accés à l'objet \textbf{RSI}.
Cette valeur est automatiquement assigné par le système lorsque l'objet RSI est créer.
D'autres entiers seront utilisés pour identifié l'objet RSI.
Et enfin, une variable de type \textbf{FRAME} sera déclaré.
C'est une variable permettant de faire la liaison avec le capteur de coordonnée du système.
Elle permet notamment de changer les coordonnées selon des nouvelles coordonnées reçu par le robot.
\\
\\
Une fois que les déclarations de variables sont terminées, on peut passer à la configuration de l'objet RSIERR en utilisant les méthodes mises à disposition.
\\
\\
La communication entre le controlleur du robot et un système externe est implémenté en utilisant l'objet \textbf{RSI ST\_ETHERNET}.
Cette objet doit être crée et configuré dans le programme KRL afin de établir la communication.
Pour activer la communication entre ces systèmes, l'utilisateur doit créer et configurer le fichier XML.
Ce fichier de configuration est spécifié et charger lorsque l'objet RSI ST\_ETHERNET est crée.
Cette objet prend trois paramètres.
\\
\\
Le premier paramètre est l'identifiant de l'objet permettant l'accés à l'objet \textbf{RSI}.
Dans notre cas, cette variable est appellée \textbf{hEthernet}.
\\
\\
Le deuxième paramètre est un entier correspondant au nombre de containeur dans lequel l'objet RSI est crée.
Nous ne voulons pas créer de containeur, on va donc préciser qu'aucun containeur doit être crée.
\\
\\
Et enfin, le troisème paramétre est le chemin d'accés vers le fichier de configuration XML. 
\\
\\
L'objet \textbf{RSI ST\_ETHERNET} peut être configuré à l'aide de la commande \textbf{ST\_SETPARAM}.
Dans notre cas, la seule configuration effectuée concerne le nombre maximum de paquets de données pouvant arriver en retard au contrôleur du robot.
Ce paramètre est appelé \textbf{eERXmaxLatePackages}, et on l'a défini à 500. 
Cela signifie que le nombre maximal de paquets de données autorisés à arriver en retard est de 500.
Cette configuration permet de gérer les éventuels retards de transmission des données tout en maintenant la stabilité et la performance de la communication entre le serveur et le robot.
\\
\\
Lorsque la partie concernant la connexion est terminé, on peut commencer à mapper les entrés de données du robot.
Pour réaliser cela, on utilise l'objet \textbf{RSI ST\_MAP2SEN\_PREA}.
Cette objet permet donc de rendre disponible la lecture de donnée que le système externe envoie.
Il prend cinq paramètres ;
\begin{itemize}
    \item Le premier paramètre est l'identifiant de l'objet. C'est donc un entier. Dans le programme KRL, il sera nommé \textbf{hMap2Prea}.
    \item Le deuxième paramètre est le numéro du containeur de l'objet RSI, dans notre cas, c'est le containeur 0.
    \item Le troisème paramètre est l'identifiant de l'objet permettant l'accés à l'objet \textbf{RSI} (hEthernet).
    \item Ensuite, le quatrième paramètre est l'index de la source de signal. Ceci est directement lié à la configuration du fichier XML, dans la balise \textbf{RECEIVE}.
    \item Et enfin, le cinquième paramètre est l'indice de la variable de système \textbf{\$SEN\_PREA[]}.
\end{itemize}
Remarque importante, les variables seront accessible avec la variables du système \textbf{\$SEN\_PREA[X]}.
Où le terme "X" est l'indice qu'on utilise pour accéder à la variable reçu.
\\
\\

Dans le but d'assurer la sécurité matérielle, on active un cycle de correction qui ajuste les mouvements du robot en fonction du système de référence utilisé, en l'occurrence le système \#WORLD.
Pour activer cette correction, on utilise la commande \textbf{ST\_ON1(\#WORLD,1)}.
Cette commande indique au robot de mettre en marche le cycle de correction lié au système de référence \#WORLD, ce qui permet d'obtenir des mouvements plus précis et adaptés à notre configuration spécifique.
\\
\\
On peut maintenant passer à la création d'une boucle permettant de récupérer les nouvelles coordonnées envoyées par le système externe.
Dans cette boucle, on utilise une variable de type \textbf{FRAME}.
Cette variable va contenir les nouvelles coordonnées à l'aide de la variable \$SEN\_PREA[X].
Une fois les coordonnées initialisées, on peut effectuer un mouvement de type PTP (Point To Point).
Ce type de mouvement permet de se déplacer d'un point à un autre de manière directe, sans suivre une trajectoire linéaire.
Il nous permet simplement de nous déplacer vers un point dans l'espace défini par les coordonnées spécifiées.

\subsection{Mouvement}

Dans cette partie, nous allons discuter des différents types de mouvements effectués par le bras Kuka afin de répondre aux différents besoins de notre projet. 
Les mouvements que nous allons aborder vont permettre d'écrire sur le clavier et de publier le tweet.

\subsubsection{Mouvement clavier}

Le mouvement du clavier a été décomposé en 3 parties.
La première étape consiste à se positionner au-dessus de la touche à écrire.
Le bras Kuka se déplace en X et Y uniquement pour cette phase. 
Une fois positionné au-dessus de la touche, le bras effectue un déplacement en Z pour appuyer sur la touche. 
Après avoir pressé la touche, le bras effectue à nouveau un déplacement en Z pour se retirer de la touche. 
Ce cycle est répété jusqu'à ce que le bras ait fini d'écrire la phrase souhaitée.
Les coordonnées de chaque touche sont stockées dans un dictionnaire appelé "Dico" dans le fichier MovementManager.py.
Ces coordonnées sont transmises au robot en fonction de la touche à écrire.
Elles permettent également d'effectuer plusieurs vérifications en comparant la position à atteindre et la position actuelle du bras :

\begin{enumerate}
    \item Vérifier que le robot se trouve bien au-dessus de la touche concernée.
    \item Vérifier que le robot a bien appuyé sur la touche du clavier.
    \item Vérifier que le robot s'est bien relevé après l'appui.
\end{enumerate}

Ces comparaisons permettent de garantir la précision et l’exactitude des mouvements à
effectuer par le bras Kuka lors de l’écriture sur le clavier.

\subsubsection{Soumission du tweet}

Une fois la phrase entièrement écrite, le robot doit maintenant soumettre le tweet.
Pour cela, nous utilisons la touche de tabulation huit fois afin de sélectionner le bouton "Tweet".
Une fois ce bouton sélectionné, nous ordonnons au robot de se diriger vers la touche "Enter" du clavier et d'appuyer dessus pour soumettre notre tweet.
Les coordonnées de la touche "Enter" et "Tabulation" sont également stockées dans un dictionnaire appelé "MousePos", qui se trouve dans le fichier MovementManager.py.
Les mêmes vérifications que celles effectuées pour l'écriture sur le clavier sont appliquées pour soumettre le tweet.
Une fois notre tweet soumis, le robot peut écrire un autre message s'il le souhaite en répétant le même schéma.

\subsection{Twitter}

Lors du lancement du programme, le robot va directement appuyer sur la touche "N".
Cette touche est un raccourci proposé par Twitter pour ouvrir rapidement et facilement la fenêtre d'écriture des tweets.
Les coordonnées permettant d'utiliser cette option sont stockées dans le dictionnaire "MousePos" sous le nom de "new", situé dans le fichier MovementManager.py.
Une fois la fenêtre ouverte, le robot va commencer à rédiger son tweet, puis le soumettre.

